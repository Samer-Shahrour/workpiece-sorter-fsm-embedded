#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/dispatch.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>
#include <iostream>
#include <thread>
#include <sys/neutrino.h>
#include <unistd.h>
#include "../../header/Hal/Actuators.h"

#include <sys/mman.h>
#include <hw/inout.h>
#include "../../header/Kommunikation/Server.h"
#include "../../header/PulseCodes.h"
#include "../../header/myTimer.h"
using namespace std;

#define ATTACH_POINT_M2 "A2_TO_A1"

timer_t connectionTimer;
static void handle_ONX_IO_msg(_pulse hdr, int rcvid){
	if (hdr.type == _IO_CONNECT ) {
		// QNX IO msg _IO_CONNECT was received; answer with EOK
		MsgReply( rcvid, EOK, NULL, 0 );
		return;
	}
	// Some other QNX IO message was received; reject it
	printf("Server received unexpected (sync.) msg type = 0x%04X\n", hdr.type);
	MsgError( rcvid, ENOSYS );
}

static void handle_pulse(_pulse pulse, int rcvid, int connectionID_Dispatcher){
	switch (pulse.code) {
		case _PULSE_CODE_DISCONNECT:
			printf("Server received _PULSE_CODE_DISCONNECT\n");
			/* A client disconnected all its connections (called
			* name_close() for each name_open() of our name) or
			* terminated. */
			ConnectDetach(pulse.scoid);
			break;
		case _PULSE_CODE_UNBLOCK:
			printf("Server received _PULSE_CODE_UNBLOCK\n");
			/* REPLY blocked client wants to unblock (was hit by
			* a signal or timed out). It's up to you if you
			* reply now or later. */
			break;
        case PULSE_HIGH_LOW_MACHINE2:
        case PULSE_LOW_HIGH_MACHINE2:
        case PULSE_M2_STATUS:
            MsgSendPulse(connectionID_Dispatcher, -1, pulse.code, pulse.value.sival_int);
            break;
        case PULSE_CONNECTION_CHECK:
            myDeleteTimer(connectionTimer);
            myStartTimer(&connectionTimer, connectionID_Dispatcher,PULSE_CONNECTION_LOST,0, false, 40);
            break;
		default:
			/* A pulse sent by one of your processes or a
			* _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
			* from the kernel? */
			break;
	}
}


void server(int connectionID_Disptacher){

	name_attach_t *attach;
	// Create a unique global name known within the network
	if ((attach = name_attach(NULL, ATTACH_POINT_M2, NAME_FLAG_ATTACH_GLOBAL)) == NULL) {
		perror("Server: name_attach failed");
		exit(EXIT_FAILURE);
	}

	while(true){
		_pulse pulse;
		int rcvid = MsgReceive(attach->chid, &pulse, sizeof(_pulse), NULL);
		if (rcvid == -1) { // Error occurred
			perror("Server: MsgReceived failed");
			break;
		}
		if (rcvid == 0) {// Pulse was received
			handle_pulse(pulse, rcvid, connectionID_Disptacher);
			continue;
		}
		if ((_IO_BASE <= pulse.type) && (pulse.type <= _IO_MAX)) {
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(pulse, rcvid);
			continue;
		}

	}

	// Server stopped; remove the name from the space
	if(name_detach(attach, 0) != 0){
		 perror("[Server] Failed to detach name!");
	 }
}
